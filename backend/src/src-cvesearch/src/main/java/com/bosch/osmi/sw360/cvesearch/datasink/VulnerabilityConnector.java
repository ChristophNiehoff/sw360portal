/*
 * Copyright (c) Bosch Software Innovations GmbH 2016.
 * Part of the SW360 Portal Project.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License Version 2.0 as published by the
 * Free Software Foundation with classpath exception.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License version 2.0 for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program (please see the COPYING file); if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */
package com.bosch.osmi.sw360.cvesearch.datasink;

import com.siemens.sw360.datahandler.common.DatabaseSettings;
import com.siemens.sw360.datahandler.couchdb.DatabaseConnector;
import com.siemens.sw360.datahandler.db.ComponentRepository;
import com.siemens.sw360.datahandler.db.ReleaseRepository;
import com.siemens.sw360.datahandler.db.VendorRepository;
import com.siemens.sw360.datahandler.thrift.RequestStatus;
import com.siemens.sw360.datahandler.thrift.components.Component;
import com.siemens.sw360.datahandler.thrift.components.Release;
import com.siemens.sw360.datahandler.thrift.cvesearch.UpdateType;
import com.siemens.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import com.siemens.sw360.vulnerabilities.common.VulnerabilityMapper;
import com.siemens.sw360.vulnerabilities.db.VulnerabilityDatabaseHandler;

import java.io.IOException;
import java.util.*;

public class VulnerabilityConnector {

    VulnerabilityDatabaseHandler vulnerabilityDatabaseHandler;
    ComponentRepository componentRepository;
    ReleaseRepository releaseRepository;
    VendorRepository vendorRepository;

    public VulnerabilityConnector() throws IOException{
        vulnerabilityDatabaseHandler = new VulnerabilityDatabaseHandler(DatabaseSettings.COUCH_DB_URL, DatabaseSettings.COUCH_DB_VM);

        DatabaseConnector db = new DatabaseConnector(DatabaseSettings.COUCH_DB_URL, DatabaseSettings.COUCH_DB_DATABASE);
        vendorRepository = new VendorRepository(db);
        releaseRepository = new ReleaseRepository(db, vendorRepository);
        componentRepository = new ComponentRepository(db, releaseRepository, vendorRepository);
    }

    ///////////////////////////////////
    // get objects from database     //
    ///////////////////////////////////
    public Optional<Release> getRelease(String releaseId){
        return Optional.ofNullable(fillVendor(releaseRepository.get(releaseId)));
    }

    private Release fillVendor(Release release){
        if (release != null) {
            vendorRepository.fillVendor(release);
        }
        return release;
    }

    public Optional<Component> getComponent(String componentId){
        return Optional.ofNullable(componentRepository.get(componentId));
    }

    public List<Release> getAllReleases() {
        List<Release> allReleases = releaseRepository.getAll();
        allReleases.forEach(vendorRepository::fillVendor);
        return allReleases;
    }



    ///////////////////////////////////////
    // write vulnerabilities to database //
    ///////////////////////////////////////

    public Map<UpdateType, List<Vulnerability>> addOrUpdateVulnerabilityAndSetId(
            Vulnerability vulnerability,
            Map<UpdateType, List<Vulnerability>> statusToVulnerabilities){

        Vulnerability dbVulnerability = vulnerabilityDatabaseHandler.getByExternalId(Vulnerability.class, vulnerability.getExternalId());
        if(dbVulnerability != null){
            if(dbVulnerability.isSetLastExternalUpdate()
                    && dbVulnerability.getLastExternalUpdate().equals(vulnerability.getLastExternalUpdate())) {
                statusToVulnerabilities.get(UpdateType.OLD).add(dbVulnerability);
                return statusToVulnerabilities;
            } else {
                dbVulnerability = VulnerabilityMapper.updateFromVulnerability(dbVulnerability, vulnerability);
                RequestStatus requestStatus = vulnerabilityDatabaseHandler.update(dbVulnerability);
                if (RequestStatus.SUCCESS.equals(requestStatus)){
                    statusToVulnerabilities.get(UpdateType.UPDATED).add(dbVulnerability);
                    return statusToVulnerabilities;
                }
             }
        } else {
            RequestStatus requestStatus = vulnerabilityDatabaseHandler.add(vulnerability);
            if (RequestStatus.SUCCESS.equals(requestStatus)){
                statusToVulnerabilities.get(UpdateType.NEW).add(vulnerability);
                return statusToVulnerabilities;
            }
        }
        statusToVulnerabilities.get(UpdateType.FAILED).add(vulnerability);
        return statusToVulnerabilities;
    }



    public Map<UpdateType, List<Vulnerability>> addOrUpdateVulnerabilitiesAndSetIds(List<Vulnerability> vulnerabilities) {
        Map<UpdateType, List<Vulnerability>> statusToVulnerabilities = new HashMap<>();
        for (UpdateType updateType: UpdateType.values()){
            statusToVulnerabilities.put(updateType, new ArrayList<>());
        }

        for (Vulnerability vulnerability : vulnerabilities) {
            statusToVulnerabilities = addOrUpdateVulnerabilityAndSetId(vulnerability, statusToVulnerabilities);
        }
        return statusToVulnerabilities;
    }

    public RequestStatus addReleaseVulnerabilityRelationsIfNecessary(String releaseId, List<String> vulnerabilityIds){
        return vulnerabilityDatabaseHandler.addRelationsIfNecessary(releaseId, vulnerabilityIds);
    }
}
